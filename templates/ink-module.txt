//! This file was autogenerated by Sumi
#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;
pub use self::{module_name}::\{
    {module_name | capitalize},
    {module_name | capitalize}Ref,
    FixedBytes,
    H160,
    U256,
};

/// EVM ID from runtime
const EVM_ID: u8 = {evm_id};

/// The EVM ERC20 delegation contract.
#[ink::contract(env = xvm_environment::XvmDefaultEnvironment)]
mod {module_name} \{
{{ for function in functions }}
    // Selector for `{function.selector}`
    const {function.name | upper_snake}_SELECTOR: [u8; 4] = hex!["{function.selector_hash}"];
{{ endfor }}

    use ethabi::Token;
    use hex_literal::hex;
    use ink_prelude::vec::Vec;
    use ink_storage::traits::\{StorageLayout, SpreadLayout};
    use scale::\{Encode, Decode};
    use scale_info::TypeInfo;

    #[ink(storage)]
    pub struct {module_name | capitalize} \{
        evm_address: H160,
    }

{{ for function in overloaded_functions }}
    /// Arguments for `{function.name}`
    #[derive(Debug, Encode, Decode, TypeInfo)]
    pub enum { function.name | upper_camel }Args \{
    {{ for variant in function.variants }}
        // Variant for `{variant.selector}`
        V{ @index } \{
            {{ for input in variant.inputs -}}
            {input.name}: {input.rust_type},
            {{ endfor }}
        },
    {{ endfor }}
    }

    {{ for variant in function.variants }}
    /// Helper implementation that can be used to mimic usual way args are passed to a message
    impl From<( {{- for input in variant.inputs -}} {input.rust_type}, {{ endfor -}})>
        for { function.name | upper_camel }Args \{
        fn from(tuple: ({{- for input in variant.inputs -}} {input.rust_type}, {{ endfor -}})) -> Self \{
            { function.name | upper_camel }Args::V{ @index } \{
                {{ for input in variant.inputs -}}
                {input.name}: tuple.{ @index },
                {{ endfor }}
            }
        }
    }
    {{ endfor }}
{{ endfor }}

    impl {module_name | capitalize} \{
        /// Create new abstraction from given contract address.
        #[ink(constructor)]
        pub fn new(evm_address: H160) -> Self \{
            Self \{ evm_address }
        }

{{ for function in overloaded_functions }}
        /// Send `{function.name}` call to contract
        #[ink(message)]
        pub fn {function.name | snake}(&mut self, args: { function.name | upper_camel }Args) -> bool \{
            let encoded_input = match args \{
                {{ for variant in function.variants -}}
                // Variant for `{variant.selector}`
                { function.name | upper_camel }Args::V{ @index }\{
                    {{ for input in variant.inputs }}{input.name},
                    {{ endfor }}
                } => \{
                    let mut buffer = Vec::from(hex!["{variant.selector_hash}"]);
                    buffer.extend(&ethabi::encode(&[
                        {{ for input in variant.inputs }}{input.name}.tokenize(),
                        {{ endfor }}
                    ]));
                    buffer
                },{{ if not @last }}
                {{ endif }}
                {{ endfor }}
            };

            self.env()
                .extension()
                .xvm_call(
                    super::EVM_ID,
                    Vec::from(self.evm_address.0.as_ref()),
                    encoded_input,
                )
                .is_ok()
        }
{{ endfor }}

{{ for function in functions }}
        /// Send `{function.name}` call to contract
        #[ink(message, selector = 0x{function.selector_hash})]
        pub fn {function.name | snake}(&mut self, {{ for input in function.inputs }}{input.name}: {input.rust_type}{{ if not @last }}, {{ endif }}{{ endfor }}) -> {function.output} \{
            let mut encoded_input = {function.name | upper_snake}_SELECTOR.to_vec();
            let input = [
                {{ for input in function.inputs -}}
                {input.name}.tokenize(),
                {{ endfor }}
            ];
            encoded_input.extend(&ethabi::encode(&input));

            self.env()
                .extension()
                .xvm_call(
                    super::EVM_ID,
                    Vec::from(self.evm_address.0.as_ref()),
                    encoded_input,
                )
                .is_ok()
        }
{{ endfor }}
    }

    /// Custom wrapper to make `H160` scale-encodable
    #[derive(Copy, Clone, Debug, Encode, Decode, TypeInfo, StorageLayout, SpreadLayout)]
    pub struct H160([u8; 20]);

    /// Custom wrapper to make `U256` scale-encodable
    #[derive(Copy, Clone, Debug, Encode, Decode, TypeInfo)]
    pub struct U256([u8; 32]);

    impl From<[u8; 20]> for H160 \{
        fn from(other: [u8; 20]) -> Self \{
            H160(other)
        }
    }

    impl From<ethabi::ethereum_types::H160> for H160 \{
        fn from(other: ethabi::ethereum_types::H160) -> Self \{
            H160(other.to_fixed_bytes())
        }
    }

    impl Into<ethabi::ethereum_types::H160> for H160 \{
        fn into(self) -> ethabi::ethereum_types::H160 \{
            ethabi::ethereum_types::H160::from(self.0)
        }
    }

    impl From<[u8; 32]> for U256 \{
        fn from(other: [u8; 32]) -> Self \{
            U256(other)
        }
    }

    impl From<ethabi::ethereum_types::U256> for U256 \{
        fn from(other: ethabi::ethereum_types::U256) -> Self \{
            U256(other.into())
        }
    }

    impl Into<ethabi::ethereum_types::U256> for U256 \{
        fn into(self) -> ethabi::ethereum_types::U256 \{
            ethabi::ethereum_types::U256::from(self.0)
        }
    }

    /// Helper trait used to convert Rust types to their serializable `Token` counterparts.
    /// Should be 100% inlined and therefore should not negatively affect smart contract size.
    trait Tokenize \{
        fn tokenize(self) -> Token;
    }

    impl<T: Tokenize, const N: usize> Tokenize for [T; N] \{
        fn tokenize(self) -> Token \{
            Token::FixedArray(self.into_iter().map(Tokenize::tokenize).collect())
        }
    }

    impl<T: Tokenize> Tokenize for Vec<T> \{
        fn tokenize(self) -> Token \{
            Token::Array(self.into_iter().map(Tokenize::tokenize).collect())
        }
    }

    /// Rust currently lacks specialization, thus overlapping trait implementations are forbidden.
    /// We use this newtype wrapper to provide custom tokenize implementation for byte arrays.
    #[derive(Debug, Encode, Decode, TypeInfo)]
    pub struct FixedBytes<const N: usize>(pub [u8; N]);

    impl<const N: usize> From<[u8; N]> for FixedBytes<N> \{
        fn from(other: [u8; N]) -> Self \{
            FixedBytes(other)
        }
    }

    impl<const N: usize> Into<[u8; N]> for FixedBytes<N> \{
        fn into(self) -> [u8; N] \{
            self.0
        }
    }

    impl<const N: usize> Tokenize for FixedBytes<N> \{
        fn tokenize(self) -> Token \{
            Token::FixedBytes(Vec::from(self.0))
        }
    }

    macro_rules! tokenize_tuple \{
        ($($i:ident),+) => \{
            impl<$($i: Tokenize,)+> Tokenize for ($($i,)+) \{
                fn tokenize(self) -> Token \{
                    #[allow(non_snake_case)]
                    let ($($i,)+) = self;

                    Token::Tuple(vec![$($i.tokenize(),)+])
                }
            }
        };
    }

    tokenize_tuple!(A);
    tokenize_tuple!(A, B);
    tokenize_tuple!(A, B, C);
    tokenize_tuple!(A, B, C, D);
    tokenize_tuple!(A, B, C, D, E);
    tokenize_tuple!(A, B, C, D, E, F);
    tokenize_tuple!(A, B, C, D, E, F, G);
    tokenize_tuple!(A, B, C, D, E, F, G, H);

    macro_rules! tokenize_ints \{
        (unsigned: $($t:ty),+) => \{
            $(
                impl Tokenize for $t \{
                    fn tokenize(self) -> Token \{
                        Token::Uint(self.into())
                    }
                }
            )+
        };

        (signed: $($t:ty),+) => \{
            $(
                impl Tokenize for $t \{
                    fn tokenize(self) -> Token \{
                        Token::Int(self.into())
                    }
                }
            )+
        };
    }

    tokenize_ints!(signed: i8, i16, i32, i64, i128);
    tokenize_ints!(unsigned: u8, u16, u32, u64, u128);

    impl Tokenize for H160 \{
        fn tokenize(self) -> Token \{
            Token::Address(self.0.into())
        }
    }

    impl Tokenize for bool \{
        fn tokenize(self) -> Token \{
            Token::Bool(self)
        }
    }

    impl Tokenize for String \{
        fn tokenize(self) -> Token \{
            Token::String(self)
        }
    }

    impl Tokenize for U256 \{
        fn tokenize(self) -> Token \{
            Token::Uint(ethabi::ethereum_types::U256::from(self.0))
        }
    }
}
