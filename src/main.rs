use std::{io::{BufReader, self, BufRead, BufWriter, Write}, fs};
use serde::Serialize;

use tinytemplate::TinyTemplate;
use std::error::Error;

use clap::Parser;

#[derive(Parser, Debug)]
struct Args {
    /// Input filename or stdin if empty
    #[arg(long, short)]
    input: Option<String>,

    /// Output filename or stdout if empty
    #[arg(long, short)]
    output: Option<String>,
}

static MODULE_TEMPLATE: &'static str = r#"
//! This code is autogenerated by Sumi
#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;

/// EVM ID
const EVM_ID: u8 = {evm_id};

/// The EVM ERC20 delegation contract.
#[ink::contract(env = xvm_environment::XvmDefaultEnvironment)]
mod {module_name} \{
    // Selector constants
{{ for selector in selectors }}
    const {selector.name}_SELECTOR: [u8; 4] = hex!["{selector.hash}"];
{{ endfor }}

    use ethabi::\{
        ethereum_types::\{
            H160,
            U256,
        },
        Token,
    };
    use hex_literal::hex;
    use ink_prelude::vec::Vec;

    #[ink(storage)]
    pub struct {struct_name} \{
        evm_address: [u8; 20],
    }

    impl {struct_name} \{
        /// Create new abstraction from given contract address.
        #[ink(constructor)]
        pub fn new(evm_address: [u8; 20]) -> Self \{
            Self \{ evm_address }
        }

        {ink_messages}

        {encode_functions}
    }
}
"#;

static ENCODE_FUNCTION_TEMPLATE: &'static str = r#"
    fn {name}_encode({{ for input in inputs }}{input.name}: {input.ink_type}{{ if not @last }}, {{ endif }}{{ endfor }}) -> Vec<u8> \{
        let mut encoded = {selector}.to_vec();
        let input = [
            {{ for input in inputs }}Token::from({input.name}.into()){{ if not @last }},
            {{ endif }}{{ endfor }}
        ];

        encoded.extend(&ethabi::encode(&input));
        encoded
    }
"#;

#[derive(Serialize)]
struct Selector {
    name: String,
    hash: String,
}

#[derive(Serialize, Default)]
struct ModuleContext {
    name: String,
    selectors: Vec<Selector>,
}

#[derive(Serialize, Default)]
struct Input {
    name: String,
    evm_type: String,
    ink_type: String,
    token_type: String,
}

#[derive(Serialize, Default)]
struct FunctionContext {
    name: String,
    inputs: Vec<Input>,
    output: String,
    selector: String,
    input_tokens: String,
}

fn main() -> Result<(), String> {
    let args = Args::parse();

    let mut reader: Box<dyn BufRead> = match args.input {
        Some(filename) => Box::new(BufReader::new(fs::File::open(filename).map_err(|e| e.to_string())?)),
        None => Box::new(BufReader::new(io::stdin())),
    };

    let mut _writer: Box<dyn Write> = match args.output {
        Some(filename) => Box::new(BufWriter::new(fs::File::create(filename).map_err(|e| e.to_string())?)),
        None => Box::new(BufWriter::new(io::stdout())),
    };

    let mut buf = String::new();
    reader.read_to_string(&mut buf).map_err(|e| e.to_string())?;

    let parsed = json::parse(&buf).map_err(|e| e.to_string())?;

    // println!("{:#?}", parsed);

    let mut template = TinyTemplate::new();
    template.add_template("function", ENCODE_FUNCTION_TEMPLATE).map_err(|e| e.to_string())?;

    for function in parsed
        .members()
        .filter(|item| item["type"] == "function" && item["stateMutability"] != "view" )
    {
        let inputs: Vec<_> = function["inputs"].members().map(|m| Input {
            name: m["name"].to_string(),
            ink_type: m["type"].to_string(),
            token_type: m["type"].to_string(), // "Token::TODO".to_string(),
            ..Default::default()
        }).collect();

        let outputs: String = function["outputs"].members().map(|m| format!("{}: {}, ", m["name"], m["type"])).collect();

        // println!("{}({}) -> {}", function["name"], inputs, outputs);
        let name = function["name"].to_string();
        let context = FunctionContext {
            selector: name.to_uppercase() + "_SELECTOR",
            name,
            inputs,
            output: "bool".to_owned(),
            ..Default::default()
        };

        let rendered = template.render("function", &context).map_err(|e| e.to_string())?;
        println!("{}\n", rendered);
    }

    // U256 -> u128
    // H160 -> [u8; 20]

    // pub fn approve(&mut self, to: [u8; 20], value: u128) -> bool {
    //     let encoded_input = Self::approve_encode(to.into(), value.into());
    //     self.env()
    //         .extension()
    //         .xvm_call(
    //             super::EVM_ID,
    //             Vec::from(self.evm_address.as_ref()),
    //             encoded_input,
    //         )
    //         .is_ok()
    // }

    // fn approve_encode(to: H160, value: U256) -> Vec<u8> {
    //     let mut encoded = APPROVE_SELECTOR.to_vec();
    //     let input = [
    //         Token::Address(to),
    //         Token::Uint(value),
    //     ];
    //     encoded.extend(&ethabi::encode(&input));
    //     encoded
    // }

    Ok(())
}

