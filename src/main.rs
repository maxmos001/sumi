use std::{io::{BufReader, self, BufRead, BufWriter, Write}, fs, collections::HashMap, fmt::Formatter, ascii::AsciiExt};
use serde::Serialize;

use tinytemplate::TinyTemplate;
use clap::Parser;
use convert_case::{Case, Casing};

#[derive(Parser, Debug)]
struct Args {
    /// Input filename or stdin if empty
    #[arg(long, short)]
    input: Option<String>,

    /// Output filename or stdout if empty
    #[arg(long, short)]
    output: Option<String>,

    /// Ink module name to generate
    #[arg(long, short)]
    module_name: String,

    /// EVM ID to use in module
    #[arg(long, short, default_value = "0x0F")]
    evm_id: String,
}

static MODULE_TEMPLATE: &'static str = r#"
//! This file was autogenerated by Sumi
#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;

/// EVM ID
const EVM_ID: u8 = {evm_id};

/// The EVM ERC20 delegation contract.
#[ink::contract(env = xvm_environment::XvmDefaultEnvironment)]
mod {name} \{
    // Selector constants
{{ for function in functions }}    const {function.name | upper_snake}_SELECTOR: [u8; 4] = hex!["{function.selector_hash}"];
{{ endfor }}

    use ethabi::\{
        ethereum_types::\{
            H160,
            U256,
        },
        Token,
    };
    use hex_literal::hex;
    use ink_prelude::vec::Vec;

    #[ink(storage)]
    pub struct {name | capitalize} \{
        evm_address: [u8; 20],
    }

    impl {name | capitalize} \{
        /// Create new abstraction from given contract address.
        #[ink(constructor)]
        pub fn new(evm_address: [u8; 20]) -> Self \{
            Self \{ evm_address }
        }

{{ for function in functions }}
        /// Send `{function.name}` call to contract
        #[ink(message)]
        pub fn {function.name | snake}({{ for input in function.inputs }}{input.name}: {input.ink_type}{{ if not @last }}, {{ endif }}{{ endfor }}) -> {function.output} \{
            let encoded_input = Self::{function.name | snake}_encode({{ for input in function.inputs }}{input.name}.into(){{ if not @last }}, {{ endif }}{{ endfor }});
            self.env()
                .extension()
                .xvm_call(
                    super::EVM_ID,
                    Vec::from(self.evm_address.as_ref()),
                    encoded_input,
                )
                .is_ok()
        }

        fn {function.name | snake}_encode({{ for input in function.inputs }}{input.name}: {input.evm_type}{{ if not @last }}, {{ endif }}{{ endfor }}) -> Vec<u8> \{
            let mut encoded = {function.name | upper_snake}_SELECTOR.to_vec();
            let input = [
                {{ for input in function.inputs }}Token::{input.token_type}({input.name}){{ if not @last }},
                {{ endif }}{{ endfor }}
            ];

            encoded.extend(&ethabi::encode(&input));
            encoded
        }
{{ endfor }}
    }
}
"#;


#[derive(Serialize)]
struct ModuleContext {
    name: String,
}

#[derive(Serialize)]
struct Input {
    name: String,
    meta_type: String,
    evm_type: String,
    ink_type: String,
    token_type: String,
}

#[derive(Serialize)]
struct Function {
    name: String,
    inputs: Vec<Input>,
    output: String,
    selector_hash: String,
}

#[derive(Serialize)]
struct Module {
    name: String,
    evm_id: String,
    functions: Vec<Function>,
}

fn main() -> Result<(), String> {
    let args = Args::parse();

    let mut reader: Box<dyn BufRead> = match args.input {
        Some(filename) => Box::new(BufReader::new(fs::File::open(filename).map_err(|e| e.to_string())?)),
        None => Box::new(BufReader::new(io::stdin())),
    };

    let mut _writer: Box<dyn Write> = match args.output {
        Some(filename) => Box::new(BufWriter::new(fs::File::create(filename).map_err(|e| e.to_string())?)),
        None => Box::new(BufWriter::new(io::stdout())),
    };

    let mut buf = String::new();
    reader.read_to_string(&mut buf).map_err(|e| e.to_string())?;

    let parsed = json::parse(&buf).map_err(|e| e.to_string())?;

    let mut template = TinyTemplate::new();
    template.add_template("module", MODULE_TEMPLATE).map_err(|e| e.to_string())?;

    template.add_formatter("snake", |value, buf| match value {
        serde_json::Value::String(s) => { *buf += &s.to_case(Case::Snake); Ok(()) },
        _ => Err(tinytemplate::error::Error::GenericError { msg: "string value expected".to_owned() }),
    });

    template.add_formatter("upper_snake", |value, buf| match value {
        serde_json::Value::String(s) => { *buf += &s.to_case(Case::UpperSnake); Ok(()) },
        _ => Err(tinytemplate::error::Error::GenericError { msg: "string value expected".to_owned() }),
    });

    template.add_formatter("capitalize", |value, buf| match value {
        serde_json::Value::String(s) => {
            let (head, tail) = s.split_at(1);

            *buf += &head.to_uppercase();
            *buf += tail;

            Ok(())
        },
        _ => Err(tinytemplate::error::Error::GenericError { msg: "string value expected".to_owned() }),
    });

    let type_map = HashMap::from([
        ("bool", ("bool", "bool", "Bool")),
        ("uint64", ("U64", "u64", "Uint")),
        ("uint256", ("U256", "u128", "Uint")),
        ("address", ("H160", "[u8; 20]", "Address")),
        ("bytes32", ("H160", "[u8; 32]", "FixedBytes")),

        // ("bool[]", ("Vec<bool>", "Array")),
        // ("uint64[]",( "Vec<U64>", "Array")),
        // ("uint256[]", ("Vec<U256>", "Array")),
        // ("address[]", ("Vec<H160>", "Array")),
    ]);

    let functions: Vec<_> = parsed
        .members()
        .filter(|item| item["type"] == "function" )
        .filter(|item| item["stateMutability"] != "view" )
        .filter(|item| item["outputs"].members().all(|output| output["type"] == "bool"))
        .map(|function| {
            let inputs: Vec<_> = function["inputs"].members().map(|m| {
                let (meta_type, (evm_type, ink_type, token_type)) = type_map
                    .get_key_value(m["type"].as_str().unwrap())
                    .expect("unknown input type");

                Input {
                    name: m["name"].to_string(),
                    meta_type: meta_type.to_string(), 
                    evm_type: evm_type.to_string(),
                    ink_type: ink_type.to_string(),
                    token_type: token_type.to_string(),
                }
            }).collect();

            // let outputs: String = function["outputs"].members().map(|m| format!("{}: {}, ", m["name"], m["type"])).collect();

            let name = function["name"].to_string();
            Function {
                name,
                inputs,
                output: "bool".to_owned(),
                selector_hash: "TODO".to_owned(),
            }
        })
        .collect();

    let module = Module {
        name: args.module_name,
        evm_id: args.evm_id,
        functions,
    };

    let rendered = template.render("module", &module).map_err(|e| e.to_string())?;
    println!("{}\n", rendered);

    Ok(())
}

